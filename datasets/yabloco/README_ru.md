# YABLoCo


## Описание задачи

Генерация кода на C/C++ с учетом длинного контекста на уровне функций

Тестируемые навыки моделей: C/C++, Long context, Code generation, Instruction following

Авторы: Айдар Валеев, Роман Гараев, Вадим Ломшаков, Ирина Пионтковская, Владимир Иванов, Израэль Адевуйи


## Мотивация

YABLoCo — это бенчмарк для генерации кода с учетом длинного контекста, включающий тестовый набор из 208 функций, отобранных из четырёх крупных
репозиториев, содержащих тысячи функций. Набор данных включает метаинформацию о функциях, контексты функций с различным уровнем
зависимостей, строку документации, тела функций и графы вызовов для каждого репозитория. Цель бенчмарка -- генерация тела функции в рамках
больших репозиториев объёмом от 200K до 2,000K строк кода (LoC) на языках C и C++, которые ранее не охватывались аналогичными бенчмарками.
Хотя бенчмарк в целом допускает использование произвольного поиска контекста по репозиториям, в предоставленной версии используется
oracle контекст — функции, извлечённые из графа вызовов, от которых должна зависеть генерируемая функция. Имея на входе oracle context,
строку документации и сигнатуру функции, модель генерирует соответствующее тело функции, которое затем тестируется с использованием 
тестов из репозитория. Модель должна понять код из предоставленного контекста и краткое описание из строки документации, чтобы
сгенерировать тело метода, реализующее необходимую функциональность. Оценка производится по двум метрикам: pass@1, отражающей
корректность реализованной функциональности, и exact match, высокое значение которой может указывать на переобучение.


## Описание датасета

### Поля данных

Каждый вопрос в датасете содержит следующие поля:

- `instruction` [str] — Промпт-инструкция для модели, содержащая шаблон для вставки элементов вопроса.
- `inputs` — Вводные данные, формирующие задание для модели. Могут включать одну или несколько модальностей - видео, аудио, изображение, текст.
    - `language` [str] — Язык программирования для написания кода (C/C++).
    - `signature` [str] — Сигнатура функции.
    - `docstring` [str] — Докстринг комментарий к функции.
    - `context` [str] — Oracle контекст -- функции, извлечённые из графа вызовов, которые вызывает оригинальный код.
- `outputs` [str] — Правильный ответ на вопрос.
- `meta` — Метаданные, относящиеся к тестовому примеру, но не используемые в вопросе (скрытые от тестируемой модели).
    - `id` [int] — Номер-идентификатор вопроса в датасете.
    - `original_id` [str] — Идентификатор функции в графе вызовов.
    - `repository` [str] — Репозиторий.
    - `fname` [str] — Имя функции.
    - `file` [str] — Исходный путь к файлу.
    - `calls_num` [int] — Количество вызовов целевой функции.
    - `dep_num` [int] — Число зависимостей, вызываемых в теле функции.
    - `same_file` [int] — Число зависимостей из того же файла, вызываемых в теле функции.
    - `same_package` [int] — Число зависимостей из того же пакета, вызываемых в теле функции.
    - `project` [int] — Число зависимостей на уровне проекта, вызываемых в теле функции.
    - `stdlib` [int] — Число зависимостей из стандартной библиотеки, вызываемых в теле функции.
    - `external_binaries` [int] — Число зависимостей из внешних бинарных файлов, вызываемых в теле функции.
    - `code_length` [int] — Длина эталонного кода.
    - `pos` [int] — Позиция кода в исходном файле.
    - `last_commit` [str] — Дата последнего коммита, связанного с телом функции.
    - `test_cov_hits` [int] — Количество попаданий по покрытию тестами.


### Пример данных

```json
{
    "instruction": "Напиши функцию на языке {language} с сигнатурой {signature} и следующим описанием: {docstring}. Используй следующий контекст:\n\n{context}",
    "inputs": {
        "language": "C",
        "context": "// File name: openssl/crypto/ui/ui_lib.c\n// Comment: \nvoid *(*UI_method_get_data_duplicator(const UI_METHOD *method)) (UI *, void *)\n{\n    if (method != NULL)\n        return method->ui_duplicate_data;\n    return NULL;\n}",
        "signature": "void *UI_add_user_data(UI *ui, void *user_data)",
        "docstring": " The following function is used to store a pointer to user-specific data.\nAny previous such pointer will be returned and replaced.\nFor callback purposes, this function makes a lot more sense than using\nex_data, since the latter requires that different parts of OpenSSL or\napplications share the same ex_data index.\nNote that the UI_OpenSSL() method completely ignores the user data. Other\nmethods may not, however."
    },
    "outputs": "void *UI_add_user_data(UI *ui, void *user_data)\n{\n    void *old_data = ui->user_data;\n\n    if ((ui->flags & UI_FLAG_DUPL_DATA) != 0) {\n        ui->meth->ui_destroy_data(ui, old_data);\n        old_data = NULL;\n    }\n    ui->user_data = user_data;\n    ui->flags &= ~UI_FLAG_DUPL_DATA;\n    return old_data;\n}",
    "meta": {
        "id": 230,
        "original_id": "1AA5FDA0028F60DA",
        "repository": "openssl",
        "fname": "UI_add_user_data",
        "file": "openssl/crypto/ui/ui_lib.c",
        "calls_num": 5,
        "dep_num": 2,
        "same_file": 1,
        "same_package": 1,
        "project": 0,
        "stdlib": 0,
        "external_binaries": 0,
        "code_length": 11,
        "pos": 371,
        "last_commit": "31.05.2017",
        "test_cov_hits": 401
    }
}
```


### Промпты

Для задачи были подготовлены 11 промптов, которые были равномерно распределены по вопросам по принципу "один вопрос – один промпт". Шаблоны в фигурных скобках в промпте заполняются из полей внутри поля `inputs` в каждом вопросе.


Пример промпта:

```
Сгенерируй функцию на языке программирования {language}. Сигнатура функции: {signature}. Описание функции: {docstring}. Используй следующий контекст:

{context}
```


### Создание датасета

Крупнейшими и наиболее популярными (по количеству звёзд) выбранными репозиториями GitHub стали: llvm-project, bullet3, openssl и redis. Ограниченное
количество репозиториев объясняется высокими затратами на включение большего числа проектов — в частности, необходимостью сборки и компиляции,
реализации Dockerfile-файлов, запуска тестов и расчёта покрытия тестами. Из каждого из выбранных репозиториев мы извлекли все функции вместе с их
вызовами, датой последнего коммита, комментариями в формате docstring, длиной кода и комментариев, а также числом попаданий в тесты. Вызовы функций
были отнесены к одной из следующих пяти категорий: 'none', 'stdlib', 'file', 'package', 'project'. В частности, 'stdlib' — для системных вызовов,
'file' и 'package' — для вызовов внутри одного файла и одного пакета соответственно, 'project' — для вызовов функций на уровне проекта. Если функция
не имела зависимостей, она попадала в категорию 'none'. Мы отфильтровали функции с чрезмерно короткой или длинной реализацией, без тестового покрытия
или комментариев. Затем были обнаружены и удалены почти дублирующие друг друга фрагменты кода. После этого оставшийся набор функций в каждой
категории контекста был отсортирован по дате последнего коммита и числу тестовых попаданий — с приоритетом к более свежим и лучше покрытым тестами
функциям. Функции из репозиториев отбирались автоматически, без учёта качества docstring-комментариев. Поэтому качество docstring было дополнительно
оценено вручную. В дополнение к сбору и очистке данных мы сгенерировали граф вызовов для каждого репозитория. Граф содержал все функции с уникальными
идентификаторами, их вызывающие и вызываемые функции, а также метаданные: длину, путь к файлу, позицию в файле, docstring, дату последнего изменения,
количество попаданий в тесты и категорию.


## Оценка


### Метрики

Для агрегированной оценки ответов моделей используются следующие метрики:

- `Pass@1`: Метрика Pass@1 вычисляет среднюю долю успешных случаев среди всех обработанных, где случай считается успешным (оценка 1), если первое сгенерированное решение проходит все модульные тесты, и неуспешным (оценка 0) в противном случае.
- `Exact match`: Метрика Exact match вычисляет среднее по оценкам всех обработанных вопросов, где оценка имеет значение 1, если предсказанная строка точно совпадает с правильным ответом, и 0 в остальных случаях.
