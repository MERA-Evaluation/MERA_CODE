{
    "dataset_name": "UnitTests",
    "license": "MERA_private",
    "dataset_size": "len(DATA)",
    "description": "Evaluation of unit-test generation for functions and methods in five programming languages (Java, Python, Go, JavaScript, and C#).",
    "modalities": [
        "code"
    ],
    "skills": [
        "Unit-tests generation",
        "Code generation"
    ],
    "domains": [],
    "universal_domains": [],
    "data_example": {
        "instruction": "Напиши тест для этого кода на языке {language} из файла '{focal_file_path}'. Напиши только тест без пояснений и комментариев.\n{focal_func}\nТебе необходимо написать {test_func_type} на языке {language}. Тест будет помещен в файл '{test_file_path}'.\nОбязательно учитывай код, собранный из будущего тестового файла: \n{test_func_context}\nДля тебя собран код из репозитория, который может помочь тебе в написании теста: \n{focal_func_context}\nОтвет:",
        "inputs": {
            "focal_func": "func IsNumeric(x interface{}) (result bool) {\n\n\t//Figure out result\n\tswitch x.(type) {\n\n\tcase int, uint:\n\t\tresult = true\n\tcase int8, uint8:\n\t\tresult = true\n\tcase int16, uint16:\n\t\tresult = true\n\tcase int32, uint32:\n\t\tresult = true\n\tcase int64, uint64:\n\t\tresult = true\n\n\tcase float32, float64:\n\t\tresult = true\n\n\tcase complex64, complex128:\n\t\tresult = true\n\n\tcase string:\n\t\tif xAsString, ok := x.(string); ok {\n\t\t\tresult = isStringNumeric(xAsString)\n\t\t} else {\n\t\t\tresult = false\n\t\t}\n\n\tdefault:\n\t\tresult = false\n\n\t}\n\n\treturn result\n}",
            "focal_func_context": "package php\n\n// IsNumeric - Finds whether a variable is a number or a numeric string\n\n#focal function/method here\n\n\nfunc isStringNumeric(x string) bool {\n\n\thasPeriod := false\n\tfor i, c := range x {\n\t\tprintln(i)\n\t\tswitch c {\n\n\t\tcase '-':\n\t\t\tif i != 0 {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\tcase '.':\n\t\t\tif hasPeriod {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\thasPeriod = true\n\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\t//Nothing here.\n\n\t\tdefault:\n\t\t\treturn false\n\n\t\t}\n\t}\n\n\treturn true\n}\n",
            "test_func_type": "function",
            "test_func_context": "package php\nimport (\n\t\"testing\"\n)",
            "language": "go",
            "focal_file_path": "php/is_numeric.go",
            "test_file_path": "php/is_numeric_test.go",
            "focal_file": "package php\n\n// IsNumeric - Finds whether a variable is a number or a numeric string\nfunc IsNumeric(x interface{}) (result bool) {\n\n\t//Figure out result\n\tswitch x.(type) {\n\n\tcase int, uint:\n\t\tresult = true\n\tcase int8, uint8:\n\t\tresult = true\n\tcase int16, uint16:\n\t\tresult = true\n\tcase int32, uint32:\n\t\tresult = true\n\tcase int64, uint64:\n\t\tresult = true\n\n\tcase float32, float64:\n\t\tresult = true\n\n\tcase complex64, complex128:\n\t\tresult = true\n\n\tcase string:\n\t\tif xAsString, ok := x.(string); ok {\n\t\t\tresult = isStringNumeric(xAsString)\n\t\t} else {\n\t\t\tresult = false\n\t\t}\n\n\tdefault:\n\t\tresult = false\n\n\t}\n\n\treturn result\n}\n\nfunc isStringNumeric(x string) bool {\n\n\thasPeriod := false\n\tfor i, c := range x {\n\t\tprintln(i)\n\t\tswitch c {\n\n\t\tcase '-':\n\t\t\tif i != 0 {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\tcase '.':\n\t\t\tif hasPeriod {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\thasPeriod = true\n\n\t\tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n\t\t\t//Nothing here.\n\n\t\tdefault:\n\t\t\treturn false\n\n\t\t}\n\t}\n\n\treturn true\n}\n",
            "test_framework": ""
        },
        "outputs": "func TestIsNumericUint8(t *testing.T) {\n\n\tvar x uint8\n\n\tx = 0\n\tif !IsNumeric(x) {\n\t\tt.Errorf(\"IsNumeric() should have returned true for uint8 [%v]\", x)\n\t}\n\n\tx = 5\n\tif !IsNumeric(x) {\n\t\tt.Errorf(\"IsNumeric() should have returned true for uint8 [%v]\", x)\n\t}\n\n\tx = 1\n\tif !IsNumeric(x) {\n\t\tt.Errorf(\"IsNumeric() should have returned true for uint8 [%v]\", x)\n\t}\n\n\tx = 123\n\tif !IsNumeric(x) {\n\t\tt.Errorf(\"IsNumeric() should have returned true for uint8 [%v]\", x)\n\t}\n\n\tx = 255\n\tif !IsNumeric(x) {\n\t\tt.Errorf(\"IsNumeric() should have returned true for uint8 [%v]\", x)\n\t}\n}",
        "meta": {
            "id": 3,
            "repo_id": "117618422",
            "focal_func_type": "function"
        }
    },
    "data_field_descriptions": {
        "instruction": {
            "ru": "default",
            "en": "default"
        },
        "inputs": {
            "focal_func": {
                "ru": "тестируемая функция/метод для тестирования",
                "en": "the focal function/method"
            },
            "test_func_type": {
                "ru": "тип теста (function/method)",
                "en": "a type of the test"
            },
            "test_func_context": {
                "ru": "контекст тестовой функции, собранный из тестового файла - импорты, глобальные переменные, краткое описание других функций/классов",
                "en": "test function context from the test file"
            },
            "language": {
                "ru": "язык программирования (python, java, csharp, js, go)",
                "en": "programming language (python, java, csharp, js, go)"
            },
            "focal_file_path": {
                "ru": "путь к файлу тестируемой функции/метода в исходном репозитории",
                "en": "the focal function/method file path"
            },
            "test_file_path": {
                "ru": "путь к файлу тестовой функции/метода в исходном репозитории",
                "en": "the test function/method file path"
            },
            "focal_file": {
                "ru": "текст файла тестируемой функции/метода",
                "en": "the focal function/method file text"
            },
            "focal_func_context": {
                "ru": "то же, что focal_file, но из текста вырезан сам тестируемый метод и заменен на текст `#focal function/method here`",
                "en": "same as `focal_file` but the focal method is replaced with the text `#focal function/method here`"
            },
            "test_framework": {
                "ru": "тестовый фреймворк, который необходимо использовать (только для JS)",
                "en": "test framework that should be used (only for JS)"
            }
        },
        "outputs": {
            "ru": "default",
            "en": "default"
        },
        "meta": {
            "id": {
                "ru": "default",
                "en": "default"
            },
            "repo_id": {
                "ru": "Идентификатор репозитория",
                "en": "The github id of the repository"
            },
            "focal_func_type": {
                "ru": "тип тестируемоего объекта(function/method)",
                "en": "a type of the focal object"
            }
        }
    },
    "prompts": [
        "Напиши тест для этого кода на языке {language} из файла '{focal_file_path}'. Напиши только тест без пояснений и комментариев.\n{focal_func}\nТебе необходимо написать {test_func_type} на языке {language}. Тест будет помещен в файл '{test_file_path}'.\nОбязательно учитывай код, собранный из будущего тестового файла: \n{test_func_context}\nДля тебя собран код из репозитория, который может помочь тебе в написании теста: \n{focal_func_context}\nОтвет:",
        "Составь тест для следующего кода на языке {language}, расположенного в '{focal_file_path}'. В ответе должен быть только тест.\n{focal_func}\nТебе необходимо написать {test_func_type} на языке {language}. Тест будет помещен в файл '{test_file_path}'.\nТебе можно использовать следующие сущности, импортированные или объявленные в тестовом файле:  \n{test_func_context}\nДля тебя собран код из репозитория, который может помочь тебе в написании теста: \n{focal_func_context}\nОтвет:",
        "Напиши тест для этого кода на языке {language} из файла '{focal_file_path}'. Напиши только тест без пояснений и комментариев.\n{focal_func}\nТебе необходимо написать {test_func_type} на языке {language}. Тест будет помещен в файл '{test_file_path}'.\nПользователь уже написал некоторый код в тестовом файле, учитывай его при написании теста: \n{test_func_context}\nДля тебя собран код из репозитория, который может помочь тебе в написании теста: \n{focal_func_context}\nОтвет:",
        "Сделай тест для этого кода, написанного на {language} из файла '{focal_file_path}'. Напиши только тестовый код.\n{focal_func}\nТебе необходимо написать {test_func_type} на языке {language}. Тест будет помещен в файл '{test_file_path}'.\nОбязательно учитывай код, собранный из будущего тестового файла: \n{test_func_context}\nУчитывай контекст приведенного кода: \n{focal_func_context}\nОтвет:",
        "Напиши тест для этого кода на языке {language} из файла '{focal_file_path}'. Напиши только тест без пояснений и комментариев.\n{focal_func}\nТебе необходимо написать {test_func_type} на языке {language}. Тест будет помещен в файл '{test_file_path}'.\nТебе можно использовать следующие сущности, импортированные или объявленные в тестовом файле: \n{test_func_context}\nОбращай внимание на следующий код при написании теста: \n{focal_func_context}\nОтвет:",
        "Составь тест для этого кода на языке {language} из файла '{focal_file_path}'. Напиши только тест без пояснений и комментариев.\n{focal_func}\nТебе необходимо написать {test_func_type} на языке {language}. Тест будет помещен в файл '{test_file_path}'.\nИспользуй {test_framework} тестовый фреймворк для написания тестового кода.\nОбязательно учитывай код, собранный из будущего тестового файла: \n{test_func_context}\nСледующие чанки кода собранные из репозитория, могут помочь тебе в составлении теста: \n{focal_func_context}\nОтвет:",
        "Сгенерируй тест для этого кода на языке {language} из файла '{focal_file_path}'. Напиши только тест без пояснений и комментариев.\n{focal_func}\nТебе необходимо написать {test_func_type} на языке {language}. Тест будет помещен в файл '{test_file_path}'.\nИспользуй {test_framework} тестовый фреймворк для написания тестового кода.\nТебе можно использовать следующие сущности, импортированные или объявленные в тестовом файле: \n{test_func_context}\nСледующие чанки кода собранные из репозитория, могут помочь тебе в составлении теста: \n{focal_func_context}\nОтвет:",
        "Напиши тест для этого кода на языке {language} из файла '{focal_file_path}'. Напиши только тестовый код.\n{focal_func}\nТебе необходимо написать {test_func_type} на языке {language}. Тест будет помещен в файл '{test_file_path}'.\nИспользуй {test_framework} тестовый фреймворк для написания тестового кода.\nПользователь уже написал некоторый код в тестовом файле, учитывай его при написании теста: \n{test_func_context}\nОбращай внимание на следующий код при написании теста: \n{focal_func_context}\nОтвет:",
        "Сгенерируй тест для этого кода на языке {language} из файла '{focal_file_path}'. Напиши только тест без пояснений и комментариев.\n{focal_func}\nТебе необходимо написать {test_func_type} на языке {language}. Тест будет помещен в файл '{test_file_path}'.\nИспользуй {test_framework} тестовый фреймворк для написания тестового кода.\nОбязательно учитывай код, собранный из будущего тестового файла: \n{test_func_context}\nТебе можно использовать следующие сущности, импортированные или объявленные в тестовом файле: \n{focal_func_context}\nОтвет:",
        "Разработайте тест для этой части программы на языке {language} из файла '{focal_file_path}'. Напиши только тестовый код.\n{focal_func}\nВам необходимо написать {test_func_type} на языке {language}. Тест будет помещен в файл '{test_file_path}'.\nИспользуй {test_framework} тестовый фреймворк для написания тестового кода.\nПользователь уже написал некоторый код в тестовом файле, учитывайте его при написании теста: \n{test_func_context}\nДля вас собран код из репозитория, который может помочь вам в написании теста:\n{focal_func_context}\nОтвет:"
    ],
    "metrics": {
        "Code BLEU": {
            "ru": "Code BLEU учитывает соответствие двух частей кода, аналогичное исходному BLEU, но может также учитывать грамматическую и логическую корректность, используя абстрактное синтаксическое дерево и структуру потока данных.",
            "en": "CodeBLEU considers the surface match similar with the original BLEU, but can also consider the grammatical correctness and the logic correctness, leveraging the abstract syntax tree and the data-flow structure.",
            "short": "code_bleu"
        }
    }
}