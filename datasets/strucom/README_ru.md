# StRuCom


## Описание задачи

Набор данных содержит структурированные русскоязычные комментарии (docstring) к функциям на 5 языках программирования (Python, Java, C#, Go, JavaScript).

Основные особенности:
- Первый специализированный корпус для русскоязычной документации
- Сочетание реальных данных с GitHub (для тестирования) и синтетических данных от Qwen2.5-Coder-32B-Instruct (для обучения)
- Строгая фильтрация по полноте и соответствию стандартам документирования
- Все комментарии приведены к одному из перечисленных форматов (Python - GoogleDoc, JavaScript - JSDoc, Java - JavaDoc, C# - XML, Go - GoDoc)

Тестируемые навыки моделей: Code documentation generation, Instruction following

Авторы: Мария Дзюба, Валентин Малых


## Мотивация

### Целевые модели и ограничения
Ориентирован на оценку моделей, поддерживающих генерацию структурированной документации (DeepSeek-Coder, Qwen2.5-Coder)

Не подходит для задач:
- Генерации неструктурированных комментариев
- Суммаризации кода 
- Объяснения кода 

### Пользователи и интерпретация результатов
Основные пользователи:
- Разработчики и исследователи в сфере NLP, занимающиеся разработкой инструментов автоматической документации

Результаты позволяют:
- Оценить способность моделей генерировать технически точные комментарии, соответствующие стандартам документирования

### Метрика:
- CHRF оценивает похожесть сгенерированного текста на эталонный по символьным n-граммам, учитывает морфологию, орфографию и грамматические окончания, особенно важные для русского языка из-за его морфологической сложности


## Описание датасета

### Поля данных

Каждый вопрос в датасете содержит следующие поля:

- `instruction` [str] — Промпт-инструкция для модели, содержащая шаблон для вставки элементов вопроса.
- `inputs` — Вводные данные, формирующие задание для модели. Могут включать одну или несколько модальностей - видео, аудио, изображение, текст.
    - `function` [str] — Функция, к которой нужно сгенерировать структурированный комментарий;
- `outputs` [str] — Правильный ответ на вопрос.
- `meta` — Метаданные, относящиеся к тестовому примеру, но не используемые в вопросе (скрытые от тестируемой модели).
    - `id` [int] — Номер-идентификатор вопроса в датасете.


### Пример данных

```json
{
    "instruction": "Напиши русскоязычную документацию к этой функции, используя формат, соответствующий её языку программирования (Python - GoogleDoc Docstring, Go - GoDoc, Java - JavaDoc, JavaScript - JSDoc, C# - XML и т.д.). \n{function}",
    "inputs": {
        "function": "private void button15_Click(object sender, EventArgs e)\n        {\n            label12.Text = \"\";\n\n            richTextBox1.Clear();\n            richTextBox2.Clear();\n            textBox1.Clear();\n            textBox2.Clear();\n            textBox4.Clear();\n        }"
    },
    "outputs": "/// <summary>\n/// Обработчик события нажатия на кнопку button15.\n/// При вызове этой функции происходит очистка текста в различных элементах управления формы:\n/// - Удаляется текст из метки label12.\n/// - Очищается содержимое многострочного текстового поля richTextBox1.\n/// - Очищается содержимое многострочного текстового поля richTextBox2.\n/// - Очищается текстовое поле textBox1.\n/// - Очищается текстовое поле textBox2.\n/// - Очищается текстовое поле textBox4.\n/// </summary>\n/// <param name=\"sender\">Объект, который вызвал событие (в данном случае, кнопка button15).</param>\n/// <param name=\"e\">Параметры события, содержащие дополнительную информацию о событии.</param>",
    "meta": {
        "id": 1
    }
}
```


### Промпты

Для задачи были подготовлены 10 промптов, которые были равномерно распределены по вопросам по принципу "один вопрос – один промпт". Шаблоны в фигурных скобках в промпте заполняются из полей внутри поля `inputs` в каждом вопросе.


Пример промпта:

```
Напиши русскоязычную документацию к этой функции, используя формат, соответствующий её языку программирования (Python - GoogleDoc Docstring, Go - GoDoc, Java - JavaDoc, JavaScript - JSDoc, C# - XML и т.д.). 
{function}
```


### Создание датасета

### Этап 1: Сбор исходных данных
- Обход русскоязычных GitHub-репозиториев с разрешительными лицензиями или без них, идентификация языка через Lingua
- Извлечение функций с помощью function_parser и Code-Text

### Этап 2: Синтетические данные
- Для генерации синтетики использовалась модель Qwen2.5-Coder-32B-Instruct

### Этап 3: Очистка и стандартизация
- Строгая фильтрация по структуре (требование полноты покрытия всех документируемых элементов в коде)
- Стандартизация стиля всех комментариев
- Фильтрация по длине (250-1000 символов)


## Оценка


### Метрики

Для агрегированной оценки ответов моделей используются следующие метрики:

- `chrf`: Метрика, оценивающая совпадение символьных n-грамм с эталонным текстом и подходящая для морфологии и орфографии русского языка
