{
    "dataset_name": "RealCodeJava",
    "license": "MERA_private",
    "dataset_size": 298,
    "description": "Function body generation benchmark built from open-sourced Java repositories from GitHub containing executable tests. Tasks focus on filling in the body of existing functions using surrounding context. Model responses are verified by running tests from the source repository.",
    "modalities": [
        "code"
    ],
    "skills": [
        "Code completion",
        "Context-aware generation"
    ],
    "domains": [],
    "synt_source_models": [],
    "data_example": {
        "instruction": "Контекст:\n```java\n{left_context}\n```\nТребуется: только тело функции. Строго соблюдай отступы. Не добавляй лишнего текста.",
        "inputs": {
            "left_context": "package org.algorithmtools.ca4j.utils;\n\nimport com.alibaba.fastjson.JSONArray;\nimport com.alibaba.fastjson.JSONObject;\nimport org.algorithmtools.ca4j.enumtype.IndicatorStatType;\nimport org.algorithmtools.ca4j.pojo.IndicatorDivisionSeries;\nimport org.algorithmtools.ca4j.pojo.IndicatorSeries;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class IndicatorSeriesUtil {\n\n    public static List<IndicatorSeries> transferFromArray(double[] array){\n"
        },
        "outputs": "        List<IndicatorSeries> list = new ArrayList<IndicatorSeries>();\n        for (int i = 0; i < array.length; i++) {\n            list.add(i, new IndicatorSeries(i, array[i], String.valueOf(i)));\n        }\n        return list;\n    }",
        "meta": {
            "id": 26,
            "repo": "algorithm-tools/CausalAnalysis",
            "base_commit": "1b714e0f22ac2259154be581065a2d4ccdfdd4ba",
            "gt": "        List<IndicatorSeries> list = new ArrayList<IndicatorSeries>();\n        for (int i = 0; i < array.length; i++) {\n            list.add(i, new IndicatorSeries(i, array[i], String.valueOf(i)));\n        }\n        return list;\n    }",
            "stub": "        return List.of();\n    }",
            "right_context": "\n\n    public static double[] transferToArray(List<IndicatorSeries> series){\n        double[] resultArray = new double[series.size()];\n        for (int i = 0; i < series.size(); i++) {\n            resultArray[i] = series.get(i).getValue();\n        }\n        return resultArray;\n    }\n\n    public static IndicatorDivisionSeries transferFromJson(String jsonString){\n        JSONObject jsonData = JSONObject.parseObject(jsonString);\n        JSONArray currentDenominatorList = jsonData.getJSONArray(\"currentDenominatorList\");\n        JSONArray currentNumeratorList = jsonData.getJSONArray(\"currentNumeratorList\");\n        JSONArray comparisonNumeratorList = jsonData.getJSONArray(\"comparisonNumeratorList\");\n        JSONArray comparisonDenominatorList = jsonData.getJSONArray(\"comparisonDenominatorList\");\n        String indicator = jsonData.getString(\"indicator\");\n        String indicatorName = jsonData.getString(\"indicatorName\");\n        String statType = jsonData.getString(\"statType\");\n\n        IndicatorDivisionSeries series = new IndicatorDivisionSeries(indicator, indicatorName, IndicatorStatType.valueOf(statType));\n        series.setCurrentNumeratorList(transferFromJsonArray(currentNumeratorList));\n        series.setCurrentDenominatorList(transferFromJsonArray(currentDenominatorList));\n        series.setComparisonNumeratorList(transferFromJsonArray(comparisonNumeratorList));\n        series.setComparisonDenominatorList(transferFromJsonArray(comparisonDenominatorList));\n\n        return series;\n    }\n\n    public static List<IndicatorSeries> transferFromJsonArray(JSONArray jsonArray){\n        return jsonArray.stream().map(v -> {\n            JSONObject data = (JSONObject) v;\n            return new IndicatorSeries(data.getLong(\"time\"), data.getDoubleValue(\"value\"), data.getString(\"logicalIndex\"));\n        }).collect(Collectors.toList());\n    }\n\n}",
            "left_context": "package org.algorithmtools.ca4j.utils;\n\nimport com.alibaba.fastjson.JSONArray;\nimport com.alibaba.fastjson.JSONObject;\nimport org.algorithmtools.ca4j.enumtype.IndicatorStatType;\nimport org.algorithmtools.ca4j.pojo.IndicatorDivisionSeries;\nimport org.algorithmtools.ca4j.pojo.IndicatorSeries;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class IndicatorSeriesUtil {\n\n    public static List<IndicatorSeries> transferFromArray(double[] array){\n",
            "image_name": "maven:3.9.9-eclipse-temurin-23-alpine",
            "build_command": "",
            "test_command": "mvn test",
            "file_path": "src/main/java/org/algorithmtools/ca4j/utils/IndicatorSeriesUtil.java",
            "PASS_TO_PASS": [
                "org.algorithmtools.ca4j.calculator.TestCalculator::testContributionMultiplyCalculator",
                "org.algorithmtools.ca4j.calculator.TestCalculator::testContributionDivisionCalculator",
                "org.algorithmtools.ca4j.calculator.TestCalculator::testContributionPlusCalculator",
                "org.algorithmtools.ca4j.calculator.TestCalculator::testContributionDivisionCalculator_forZero",
                "org.algorithmtools.ca4j.calculator.TestCalculator::testJSDivergence",
                "org.algorithmtools.ca4j.calculator.TestCalculator::test"
            ],
            "FAIL_TO_PASS": [],
            "intent": "transferFromArray[function]",
            "intent_type": "function"
        }
    },
    "data_field_descriptions": {
        "instruction": {
            "ru": "строка, содержащая формулировку задания по генерации тела функции",
            "en": "string containing the task formulation for function body generation"
        },
        "inputs": {
            "left_context": {
                "ru": "код перед функцией, включая импорты и классы",
                "en": "code appearing before the target function"
            }
        },
        "outputs": {
            "ru": "одномерный массив строк размера n_samples, где n_samples — количество требуемых сэмплов для подсчета pass@k",
            "en": "one-dimensional array of strings of size n_samples, where n_samples is the number required to compute pass@k"
        },
        "meta": {
            "id": {
                "ru": "уникальный идентификатор примера",
                "en": "unique identifier of the example"
            },
            "repo": {
                "ru": "имя GitHub-репозитория, из которого извлечена задача",
                "en": "GitHub repository name the task is taken from"
            },
            "base_commit": {
                "ru": "хэш коммита, зафиксировавшего состояние репозитория",
                "en": "commit hash fixing the repo state"
            },
            "gt": {
                "ru": "тело функции-истины без сигнатуры",
                "en": "ground truth function body (no signature)"
            },
            "stub": {
                "ru": "тело функции-заглушки без сигнатуры",
                "en": "stub function body (no signature)"
            },
            "right_context": {
                "ru": "код после функции, включая другие функции и классы",
                "en": "code appearing after the target function"
            },
            "left_context": {
                "ru": "код перед функцией, включая импорты и классы",
                "en": "code appearing before the target function"
            },
            "image_name": {
                "ru": "Docker-образ, в котором выполняется проект",
                "en": "Docker image for running the project"
            },
            "build_command": {
                "ru": "команда для сборки проекта перед тестами",
                "en": "command to build the project before tests"
            },
            "test_command": {
                "ru": "команда запуска тестов",
                "en": "command to run the tests"
            },
            "file_path": {
                "ru": "путь до файла, в котором находится функция",
                "en": "path to the file containing the function"
            },
            "PASS_TO_PASS": {
                "ru": "список тестов, которые успешно проходят",
                "en": "tests that pass with the generated function"
            },
            "FAIL_TO_PASS": {
                "ru": "список тестов, которые перестали падать",
                "en": "tests that used to fail and now pass"
            },
            "intent": {
                "ru": "название функции или метода",
                "en": "function or method name"
            },
            "intent_type": {
                "ru": "тип элемента (function, class и т.д.)",
                "en": "element type (function, class, etc.)"
            }
        }
    },
    "prompts": [
        "Есть контекст задачи:\n{left_context}\n\nПоследняя функция в контексте имеет только сигнатуру и открытую скобку {. Требуется написать содержимое этой функции, завершив его закрывающей скобкой }. Не добавляйте в ответ другие функции и классы. Придерживайтесь отступов и форматирования, как в контексте. Ответ оформите так: \n```java\n<code>\n```\nВаш ответ будет добавлен к контексту. Получившийся Java код должен успешно пройти компиляцию и unit тесты.",
        "Дан контекст перед функцией:\n```java\n{left_context}\n```\nПродолжите писать **содержимое** метода сразу после открывающей фигурной скобки и завершите Ваш ответ закрывающей фигурной скобкой, чтобы получился корректный код. Оформите свой ответ в блоке кода: \n```java\n<code>\n```\nСтарайтесь соблюдать форматирование, как в контексте. Содержимое Вашего ответа будет вставлено сразу после контекста и загружено в компилятор для дальнейшего тестирования.",
        "Есть начало файла:\n{left_context}\nТвоя задача — дописать содержимое одной функции. Начни писать код сразу после сигнатуры, не повторяй ее в твоем ответе, она уже есть в файле. Не забудь закрыть тело функции закрывающей скобкой \"}\". Весь твой ответ должен быть внутри блока: \n```java\n<code>\n```\nОтвет будет добавлен в файл, и файл отправится в компилятор javac для проверки.",
        "Используй следующий код:\n{left_context}\nПродолжи писать содержимое последней функции и заверши его финальной скобкой }. Ответ помести в блок: \n```java\n<code>\n```\nСоблюдай отступы и форматирование, как в примере. Не добавляй в ответ сигнатуру функции и не пиши другие функции и классы. Текст твоего ответа будет вставлен в конец примера, и получившийся код будет проверен.",
        "На основе следующего примера:\n{left_context}\nПродолжи писать незавершенную функцию сразу после сигнатуры (не повторяй ее в твоем ответе) и открывающей скобки {. Заверши ответ закрывающей скобкой }, чтобы после объединения примера с твоим ответом получился корректный код. Соблюдай отступы и code style, как в примере. Оформи ответ в таком виде: \n```java\n<code>\n```\n",
        "Перед Вами часть файла с кодом на языке Java:\n```java\n{left_context}\n```\nПоследняя функция в файле осталась незавершенной, есть только ее сигнатура. Сразу с этого места продолжите писать содержимое этой функции, завершив ответ закрывающей скобкой \"}\", чтобы после добавления Вашего ответа к файлу выше получился синтаксически верный код. Придерживайтесь стиля и форматирования кода как в примере. Ответ поместите в блок: \n```java\n<code>\n```\nВаш ответ будет вставлен в файл и проверен компилятором и тестами.",
        "Вот начало кода:\n{left_context}\nПродолжи незавершенный метод сразу после фигурной скобки \"{\". Напиши только содержимое этого метода (без сигнатуры) и заверши ответ закрывающей скобкой \"}\". Весь ответ помести в блок: \n```java\n<code>\n```\nПридерживайся code style из примера. Твой ответ будет вставлен в этот метод и получившийся код будет протестирован.",
        "Представь, что ты - джава-синьор. Перед тобой задание:\n{left_context}\nПродолжи писать последний метод (функцию) до его логического завершения, включая закрывающую фигурную скобку. Соблюдай отступы и форматирование в коде. Комментарии и объяснения можешь не писать. Оформи ответ в виде: \n```java\n<code>\n```\nИсходный код из задания будет объединен с твоим ответом, и получившийся файл будет проверен компилятором и тестами.",
        "Вашему вниманию представлен исходный код:\n{left_context}\nОн заканчивается незавершенной функцией, и Вам нужно написать ее содержимое. Продолжайте писать содержимое этой функции сразу после ее сигнатуры и открывающей фигурной скобки \"{\" и завершите Ваш ответ симметричной скобкой \"}\". Если поместить Ваш ответ после исходного кода, объединив их, должен получиться работающий код на Java, который пройдет этап компиляции и последующие тесты. Ответ должен быть оформлен в блоке: \n```java\n<code>\n```Просим не нарушать исходного форматирования и придерживаться отступов подобно исходному коду.",
        "В представленном ниже примере продолжи незаконченную функцию строго после открывающей фигурной скобки {. Не пиши в ответе сигнатуру функции и не добавляй в ответ другие функции и классы. Заверши ответ закрывающей фигурной скобкой }. Старайся соблюдать отступы и форматирование как в примере. Вот сам пример:\n{left_context}\n\nТвой ответ будет присоединен к этому коду и проверен. Продолжение тела функции оформи в блоке: \n```java\n<code>\n```\n"
    ],
    "metrics": {
        "pass@1": {
            "ru": "доля задач, в которых хотя бы одна генерация прошла все тесты",
            "en": "fraction of tasks where at least one generation passes all tests",
            "short": "pass@1"
        },
        "pass_oracle@1": {
            "ru": "доля задач, в которых ground truth решение проходит все тесты (верхняя граница)",
            "en": "fraction of tasks where the ground truth solution passes all tests (oracle upper bound)",
            "short": "pass_oracle@1"
        },
        "pass_stub_pass@1": {
            "ru": "доля задач, в которых заглушка (stub) прошла хотя бы один тест",
            "en": "fraction of tasks where stub function body passed at least one test",
            "short": "pass_stub_pass@1"
        },
        "pass_dry_run@1": {
            "ru": "доля задач, где хотя бы одна генерация прошла тесты в режиме dry-run (без использования ground truth)",
            "en": "fraction of tasks where at least one generation passes in dry-run mode (without using ground truth)",
            "short": "pass_dry_run@1"
        },
        "execution_success": {
            "ru": "доля задач, в которых проект успешно собрался и тесты запустились без сбоев",
            "en": "fraction of tasks where the project built and tests executed without failure",
            "short": "execution_success"
        },
        "num_samples": {
            "ru": "общее количество задач в датасете",
            "en": "total number of tasks in the dataset",
            "short": "num_samples"
        }
    }
}